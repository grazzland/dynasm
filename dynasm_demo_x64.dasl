--go@ luajit dynasm.lua *

--setup ------------------------------------------------------------------------------------------------------------------

local ffi = require'ffi'
local dasm = require'dasm'

|.arch x64
|
|.actionlist actions
|.section sec1, sec2
|.globals global_
|.globalnames globalnames
|.externnames externnames

local Dst, globals = dasm.new(actions, externnames, DASM_MAXSECTION, DASM_MAXGLOBAL)

--immediate value substitution -------------------------------------------------------------------------------------------

local x, y = 0x33, 0x44
local n = 2
local m = bit.tobit(0xDeadbeef)

|  mov ax, x+y             // 0x77
|  mov Rd(n), m            // Rd(2) = edx
|  fld Rf(n)               // Rf(2) = st2
|  mov eax, [ebx + ecx * 8 + m]         // max. 2G const displacement with this form
|  mov eax, [m]                         // full 4G const address with this form
| nop

--type macros ------------------------------------------------------------------------------------------------------------

if not rawget(_G, '__TYPEDEFS') then
	__TYPEDEFS = true
	ffi.cdef'typedef struct Type1 {int f1; int f2;} Type1'
	ffi.cdef'typedef Type1 Type2'
end

local n,m = 1,1

|.type TP1, Type1, eax
|.type TP2, Type2, ebx
|
|  mov eax, TP1->f1        // +0
|  mov ebx, TP1.f2         // +4
|  mov ecx, TP2[n+m]->f1   // +16
|  mov edx, TP2[n-2*m].f2  // -4
|  nop

--address substution -----------------------------------------------------------------------------------------------------

local addr = bit.tobit(0xDeadbeef)
local ptr = ffi.cast("void*", 0xDeadbeefDeadbeefULL)

|  jmp &addr            // works with normalized numbers
|  jmp &ptr             // works with pointers too
|  nop

--code sections ----------------------------------------------------------------------------------------------------------

|.sec1; mov ax, 1
|.sec2; mov ax, 2
|.sec1; mov bx, 1
|.sec2; mov bx, 2
|  nop

--global labels ----------------------------------------------------------------------------------------------------------

|->l1:
|  jmp ->l2
|
|->l2:
|  jmp ->l1
|
|  nop

--local labels -----------------------------------------------------------------------------------------------------------

|2:
|1:
|  jmp >1
|1:
|  jmp <2
|
|  nop

--label addresses --------------------------------------------------------------------------------------------------------

|->label5:
|  mov eax, [->label5]

--align and inline data --------------------------------------------------------------------------------------------------

local n = 0x90
|  mov eax, 0x22222222
|.byte n
|.align word                        // puts nop too
|.word bit.bor(bit.lshift(n,8), n)  // expressions work too
|.align dword                       // puts nop too
|.space 1+1, 0x90                   // size can be variable, filler must be constant
|  mov eax, 0x22222222

--conditional compilation ------------------------------------------------------------------------------------------------

|.define def1
|.if def1
|  .nop
|.elif def2
|  .fatal this won't be parsed
|.else
|  .fatal this won't be parsed
|.endif
|  nop

--macros -----------------------------------------------------------------------------------------------------------------

|.macro saveregs
|  push rbp; push rdi; push rsi; push rbx
|.endmacro
|
|.macro restoreregs
|  pop rbx; pop rsi; pop rdi; pop rbp
|.endmacro
|
|.macro cat, s1, s2, s3
| s1 .. s2 .. s3
|.endmacro
|
|  saveregs
|  restoreregs
|  mov eax, 0x10000000
|  cat n, o, p

--captures ---------------------------------------------------------------------------------------------------------------

|.capture c1; mov eax, 0x1a; .endcapture
|.capture c2; mov ebx, 0x2a; .endcapture
|.capture c1; mov eax, 0x1b; .endcapture
|.capture c2; mov ebx, 0x2b; .endcapture
|.dumpcapture c1
|.dumpcapture c2
|.dumpcapture c2  // we can dump it again

--externs ----------------------------------------------------------------------------------------------------------------

local s1, s2 = 'Hello from %s!\n', 'DynASM'
local p1 = ffi.cast('const char*', s1)
local p2 = ffi.cast('const char*', s2)

|->test_externs:
|  push &p2
|  push &p1
|  call extern printf
|  add rsp, 8
|  mov rax, 42
|  ret

--building, i.e. checking, linking, mmapping, encoding, mprotecting ------------------------------------------------------

local buf, size = Dst:build()

--inspecting -------------------------------------------------------------------------------------------------------------

print('code address', buf)
print('code size   ', size)

for i = 0, #globalnames do --from .globalnames directive
	print(string.format('global %-8s %s', globalnames[i], globals[i]))
end

for i = 0, #externnames do --from .externnames directive
	print(string.format('extern %-8s', externnames[i]))
end

--disassembling ----------------------------------------------------------------------------------------------------------

print'-----------------------------------------'
dasm.dump(buf, size)
print'-----------------------------------------'

--running the test program -----------------------------------------------------------------------------------------------

--make a map of label name -> address
local labels = {}
for i = 0, #globalnames do
	labels[globalnames[i]] = globals[i]
end

local test_externs = ffi.cast('int __cdecl (*) ()', labels.test_externs)
assert(test_externs() == 42)
print''

